---
title: "AOR Aggregation"
format: html
editor: source
---

```{r}
# libraries
library(readxl)
library(tidyverse)
library(janitor)
library(lubridate)
library(sf)
library(arrow)
library(knitr)
library(kableExtra)
library(dbscan)
```

Loading in cleaned ICE encounters dataset

```{r}
ice <- read_csv('data/ice_encounters_cleaned.csv')
```




## Bin citizenship country
Read in responsible sites data
```{r}
offices0 <- st_read("data/us_ice_office_points.gpkg")
```
```{r}
head(offices0)
```


```{r}
# renaming
offices <- offices0 |>
  rename(office = responsible_site) |> 
  rename(dep_country = departure_country) |>
  rename(criminality = encounter_criminality) |>
  rename(cit_country = citizenship_country) 
```

```{r}
# offices <- offices |> 
#   mutate(
#     cit_country = str_to_title(cit_country),
#     region = case_when(
#       # --- Canada + Mexico ---
#       cit_country == "Canada" ~ "Canada",
#       cit_country == "Mexico" ~ "Mexico",
#   
#       # --- Caribbean (including dependencies) ---
#       cit_country %in% c(
#         "Jamaica", "Haiti", "Dominican Republic", "Cuba",
#         "Puerto Rico", "US Virgin Islands", "British Virgin Islands",
#         "Cayman Islands", "Aruba", "Curacao", "Bonaire",
#         "Guadeloupe", "Martinique", "Bermuda", "Montserrat",
#         "Anguilla", "Saint Martin", "Sint Maarten",
#         "Antigua and Barbuda", "Dominica", "Grenada",
#         "Saint Lucia", "Saint Vincent and the Grenadines",
#         "Trinidad and Tobago", "The Bahamas", "Barbados",
#         "Saint Kitts and Nevis", "Turks and Caicos Islands"
#       ) ~ "Caribbean",
#   
#       # --- Central America ---
#       cit_country %in% c(
#         "Belize", "Guatemala", "Honduras", "El Salvador",
#         "Nicaragua", "Costa Rica", "Panama"
#       ) ~ "Central America",
#   
#       # --- South America ---
#       cit_country %in% c(
#         "Argentina", "Bolivia", "Brazil", "Chile", "Colombia",
#         "Ecuador", "Guyana", "Paraguay", "Peru",
#         "Suriname", "Uruguay", "Venezuela"
#       ) ~ "South America",
#   
#       # --- Africa ---
#       cit_country %in% c(
#         "Algeria", "Angola", "Benin", "Botswana", "Burkina Faso",
#         "Burundi", "Cabo Verde", "Cameroon", "Central African Republic",
#         "Chad", "Comoros", "Congo", "Democratic Republic of the Congo",
#         "Djibouti", "Egypt", "Equatorial Guinea", "Eritrea",
#         "Eswatini", "Ethiopia", "Gabon", "Gambia", "Ghana",
#         "Guinea", "Guinea-Bissau", "Ivory Coast", "Kenya",
#         "Lesotho", "Liberia", "Libya", "Madagascar", "Malawi",
#         "Mali", "Mauritania", "Mauritius", "Morocco", "Mozambique",
#         "Namibia", "Niger", "Nigeria", "Rwanda", "Sao Tome and Principe",
#         "Senegal", "Seychelles", "Sierra Leone", "Somalia",
#         "South Africa", "South Sudan", "Sudan", "Tanzania",
#         "Togo", "Tunisia", "Uganda", "Zambia", "Zimbabwe"
#       ) ~ "Africa",
#   
#       # --- Asia ---
#       cit_country %in% c(
#         # East Asia
#         "China", "Japan", "South Korea", "North Korea", "Mongolia", "Taiwan",
#         # Southeast Asia
#         "Indonesia", "Thailand", "Vietnam", "Malaysia",
#         "Singapore", "Philippines", "Cambodia", "Laos",
#         "Myanmar", "Brunei", "Timor-Leste",
#         # South Asia
#         "India", "Pakistan", "Bangladesh", "Nepal",
#         "Sri Lanka", "Bhutan", "Maldives",
#         # Central Asia (your rule)
#         "Kazakhstan", "Kyrgyzstan", "Tajikistan",
#         "Turkmenistan", "Uzbekistan",
#         # Middle East (your rule)
#         "Saudi Arabia", "United Arab Emirates", "Qatar", "Kuwait",
#         "Bahrain", "Oman", "Yemen", "Jordan",
#         "Lebanon", "Syria", "Iraq", "Iran",
#         "Israel", "Palestine", "Turkey"
#        
#       ) ~ "Asia",
#   
#       # --- Europe (includes Russia) ---
#       cit_country %in% c(
#         "United Kingdom", "Ireland", "France", "Germany", "Spain", "Portugal",
#         "Italy", "Belgium", "Netherlands", "Luxembourg",
#         "Switzerland", "Austria", "Poland", "Czech Republic",
#         "Slovakia", "Hungary", "Slovenia", "Croatia",
#         "Serbia", "Bosnia and Herzegovina", "Montenegro",
#         "North Macedonia", "Albania", "Greece",
#         "Bulgaria", "Romania", "Moldova", "Ukraine", "Belarus",
#         "Lithuania", "Latvia", "Estonia",
#         "Norway", "Sweden", "Finland", "Denmark", "Iceland",
#         "Georgia", "Armenia", "Azerbaijan", "Russia"
#       ) ~ "Europe",
#   
#       # --- Oceania ---
#       cit_country %in% c(
#         "Australia", "New Zealand", "Papua New Guinea",
#         "Fiji", "Samoa", "Tonga", "Vanuatu", "Solomon Islands",
#         "Kiribati", "Micronesia", "Palau",
#         "Marshall Islands", "Nauru", "Tuvalu"
#       ) ~ "Oceania",
#   
#       TRUE ~ NA_character_
#     )
#   )

```




```{r}
offices_clean <- offices |>
  drop_na(criminality, gender, age, region) |>
  st_transform(crs = "ESRI:102010")

nrow(offices_clean)
```

### Add state information
```{r}
states <- read_sf("data/gadm41_USA_1.json")

states <- st_transform(states, crs = "ESRI:102010")

```


## Clustering 
```{r}
num_encounters <- offices_clean |>
  group_by(office) |>
  summarize(num_encounters = n()) |>
  st_join(states, join = st_intersects) |>
  # ERO - Champlain, NY Sub-Office doesn't get assigned to a state for some reason; b/c it's along the border?
  mutate(NAME_1 = ifelse(office == "ERO - Champlain, NY Sub-Office", "NewYork", NAME_1))|>
  select(office, num_encounters, NAME_1) |>
  rename("state" = "NAME_1")
```

### Group by state, then run DBSCAN within each state
```{r}
state_vec <- as.vector(states$NAME_1)

# create clusters of offices within each state boundary
divide_and_cluster <- function(state_vector, enc_data) {
  # for continuous enumeration
  cluster_offset <- 0
  # empty df to store cluster results
  cluster_results <- st_sf(
    office = character(0),
    num_encounters = integer(0),
    state = character(0),
    geom = st_sfc(crs="ESRI:102010")
  )

  for (s in state_vector) {
    subset <- enc_data |>
      filter(state == s) 
    #print(table(subset$office) |> summary())
    
    # skip states w no offices
    if (nrow(subset) == 0) next
    
    coords <- st_coordinates(subset)
    
    db_clusters <- dbscan(coords, eps = 100000, minPts=1) # eps units are in meters
    
    # for continuous enumeration
    clusters_shifted <- db_clusters$cluster + cluster_offset
    
    cluster_offset <- max(clusters_shifted )
    
    subset$cluster <- clusters_shifted 
    
    cluster_results <- rbind(cluster_results, subset)
    #print(head(cluster_results))
  }
  return(cluster_results)
}

cluster_results <- divide_and_cluster(state_vec, num_encounters)

```

```{r}
length(unique(cluster_results$office))
length(unique(num_encounters$office))
```



```{r}
cluster_summary <- cluster_results |>
  group_by(cluster) |>
  summarize(agg_num_encounters = sum(num_encounters),
            num_offices = n_distinct(office),  # should be > 1 for at least some clusters
            num_states = n_distinct(state),
            state = first(state)) |> # should = 1 for all cluster
  arrange((num_offices))

cluster_summary
```

Merge each small cluster with its nearest neighbor (within the same state) until it reaches ≥1000, or stop if there are no more clusters available
```{r}
# merge each small cluster with its nearest neighbor (within the same state) until it reaches ≥1000, or stop if there are no more clusters available

small_clusters <- cluster_summary |>
  filter(agg_num_encounters < 1000)

# helper function to find candidates to merge with
find_merge_candidates <- function(curr_cluster, curr_encounters, curr_state, curr_geom, all_clusters) {
  merge_list <- curr_cluster
  
  available <- all_clusters |>
    filter(state == curr_state,
           !(cluster %in% merge_list)) 
  
  while ((curr_encounters < 1000) & (nrow(available) > 0)) {
    # find nearest available cluster
    nearest_idx <- which.min(st_distance(curr_geom, available$geom))
    nearest_cluster <- available[nearest_idx, ]$cluster
    
    merge_list <- c(merge_list, nearest_cluster)
    curr_encounters <- curr_encounters + available[nearest_idx, ]$agg_num_encounters
    
    # remove cluster from available list
    available <- available |>
      filter(cluster != nearest_cluster)
  }
  
  return(merge_list)
  
}

nearest <- small_clusters |>
  rowwise() |> # to perform operations one row at a time
  mutate(
    clusters_to_merge = {
      list(find_merge_candidates(cluster, agg_num_encounters, state, geom, cluster_summary))
    },
    # assign final cluster id to the biggest original cluster
    final_cluster_id = {
      merged_clusters <- cluster_summary |>
        filter(cluster %in% clusters_to_merge) |>
        select(cluster, agg_num_encounters)
      
      merged_clusters$cluster[which.max(merged_clusters$agg_num_encounters)]
    }
  ) |>
  ungroup()

# 47 final clusters
length(unique(nearest$final_cluster_id))

```



Merge cluster assignments to office-level data
```{r}
merge_lookup <- nearest |>
  select(cluster, clusters_to_merge, final_cluster_id) |>
  # unnest so each cluster in clusters_to_merge gets its own row
  unnest(clusters_to_merge) |>
  rename(og_cluster = clusters_to_merge) |>
  select(og_cluster, final_cluster_id) |>
  distinct()

# join back to original office-level cluster results
cluster_results_final <- cluster_results |>
  st_drop_geometry() |> 
  left_join(merge_lookup, by=c("cluster" = "og_cluster")) |>
  mutate(final_cluster_id = coalesce(final_cluster_id, cluster)) |>
  select(-state, -cluster) |>
  rename(cluster = final_cluster_id)
  


```



```{r}
cluster_results_final |>
  group_by(cluster) |>
  summarize(total_cluster_encounters = sum(num_encounters))
```

```{r}
length(unique(cluster_results_final$office))
```

```{r}
length(unique(offices_clean$office))
```


Merge with individual-level data
```{r}
offices_clustered <- offices_clean |>
  left_join(cluster_results_final, by = "office") |>
  mutate(cluster = as.factor(cluster)) |>
  select(-geom.y) |>
  rename("geom" = "geom.x")
  
```

```{r}
#st_crs(offices_clustered)
offices_clustered |>
  filter(is.na(cluster))
```





## Create county shapefile with Encounters information

```{r}
aors_counties <- st_read('data/aors_counties/aors_counties.shp')
```

Loading in ACS data that has info on native/foreign born populations by county

```{r}
nat_cit <- read_csv('data/nat_cit_cleaned.csv')
#colnames(nat_cit)
```

Loading in Decennical Census data that has info on race and ethnicity by county

```{r}
race_ethn <- read_csv('data/race_ethn_cleaned.csv')
#colnames(race_ethn)
```

Merge with county shapefile

```{r}

county_info_merged <- aors_counties |>         
  left_join(nat_cit,  by="fips") |>
  left_join(race_ethn, by="fips")

```

```{r}

county_info_merged <- county_info_merged |>
  select("name", 
         "state_name",
         "state_abbr",
         "state_fips",
         "county_fip",
         "fips",
         "population",
         "pop_sqmi",
         "shape_leng",
         "shape_area",
         "aor",
         "prop_not_a_citizen",
         "prop_black",
         "prop_asian",
         "prop_hispanic_or_latino",
         "geometry")
```

```{r}
county_info_merged |> st_geometry() |> head()
```



```{r}
county_info_transf <- st_transform(county_info_merged, crs="ESRI:102010")
st_crs(county_info_transf)
```


## Match counties with the closest office
```{r}
clustered_offices_dissolved <- offices_clustered |>
  group_by(office) |>
  summarize()
```

### Assign the nearest office to each county using the dissolved office data
```{r}
counties_offices_joined <-st_join(county_info_transf, clustered_offices_dissolved, join = st_nearest_feature)
```

```{r}
head(counties_offices_joined)
```


## Merge county demographics with ICE data


Group by office, then take the means of the demographic variables and create a variable of the population density
```{r}
office_county_agg <- counties_offices_joined |>
  group_by(office) |>
  reframe(avg_p_blk = mean(prop_black),
         avg_p_asn = mean(prop_asian),
         avg_p_his = mean(prop_hispanic_or_latino),
         avg_p_nc = mean(prop_not_a_citizen),
         avg_pop_sqm = mean(pop_sqmi)) |>
  st_drop_geometry()
```


Join by office
```{r}
cnty_clus_offices <- offices_clustered |>
  left_join(office_county_agg, by = "office") |>
  select(-office_lat, -office_lon)

head(cnty_clus_offices)
```




```{r}
cnty_clus_offices_fixed <- cnty_clus_offices |>
  mutate(cluster = as.character(cluster))
```


```{r}
cnty_clus_offices |>
  filter(is.na(cluster))
```

```{r}
saveRDS(cnty_clus_offices_fixed, "data/cnty_clus_offices.rds")

```

```{r}
cnty_clus_offices_fixed <- readRDS("data/cnty_clus_offices.rds")
```

```{r}
head(cnty_clus_offices_fixed)
```


Export
```{r}
if (file.exists("data/cnty_clus_offices.gpkg")) {
  file.remove("data/cnty_clus_offices.gpkg")
}
st_write(cnty_clus_offices_fixed, "data/cnty_clus_offices.gpkg")

```

